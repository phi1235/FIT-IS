server:
  port: ${SERVER_PORT:8082}
  # Request size limiting
  max-http-header-size: ${SERVER_MAX_HTTP_HEADER_SIZE}
  max-http-post-size: ${SERVER_MAX_HTTP_POST_SIZE}
  tomcat:
    max-swallow-size: ${TOMCAT_MAX_SWALLOW_SIZE}
    max-connections: ${TOMCAT_MAX_CONNECTIONS}
    threads:
      max: ${TOMCAT_THREADS_MAX}
      min-spare: ${TOMCAT_THREADS_MIN_SPARE}

spring:
  application:
    name: ${SPRING_APPLICATION_NAME}
  # Request body size limiting
  servlet:
    multipart:
      enabled: ${SPRING_SERVLET_MULTIPART_ENABLED:true}
      max-file-size: ${SPRING_SERVLET_MULTIPART_MAX_FILE_SIZE}
      max-request-size: ${SPRING_SERVLET_MULTIPART_MAX_REQUEST_SIZE}
      file-size-threshold: ${SPRING_SERVLET_MULTIPART_FILE_SIZE_THRESHOLD}
  
  # PostgreSQL DataSource Configuration
  datasource:
    url: jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}
    driver-class-name: ${SPRING_DATASOURCE_DRIVER_CLASS_NAME:org.postgresql.Driver}
    username: ${POSTGRES_USER}
    password: ${POSTGRES_PASSWORD}
    hikari:
      maximum-pool-size: ${SPRING_DATASOURCE_HIKARI_MAXIMUM_POOL_SIZE}
      minimum-idle: ${SPRING_DATASOURCE_HIKARI_MINIMUM_IDLE}
      connection-timeout: ${SPRING_DATASOURCE_HIKARI_CONNECTION_TIMEOUT}
      idle-timeout: ${SPRING_DATASOURCE_HIKARI_IDLE_TIMEOUT}
      max-lifetime: ${SPRING_DATASOURCE_HIKARI_MAX_LIFETIME}
  
  jpa:
    hibernate:
      ddl-auto: ${SPRING_JPA_HIBERNATE_DDL_AUTO}
    show-sql: ${SPRING_JPA_SHOW_SQL}
    properties:
      hibernate:
        dialect: ${SPRING_JPA_PROPERTIES_HIBERNATE_DIALECT}
        format_sql: ${SPRING_JPA_PROPERTIES_HIBERNATE_FORMAT_SQL}
        jdbc:
          batch_size: ${SPRING_JPA_PROPERTIES_HIBERNATE_JDBC_BATCH_SIZE}
        order_inserts: ${SPRING_JPA_PROPERTIES_HIBERNATE_ORDER_INSERTS}
        order_updates: ${SPRING_JPA_PROPERTIES_HIBERNATE_ORDER_UPDATES}
  
  # H2 Console (disabled - using PostgreSQL)
  # h2:
  #   console:
  #     enabled: false
  #     path: /h2-console
  
  # Redis Configuration
  redis:
    host: ${REDIS_HOST}
    port: ${REDIS_PORT}
    password: ${REDIS_PASSWORD}
    timeout: ${SPRING_REDIS_TIMEOUT}
    lettuce:
      pool:
        max-active: ${SPRING_REDIS_LETTUCE_POOL_MAX_ACTIVE}
        max-idle: ${SPRING_REDIS_LETTUCE_POOL_MAX_IDLE}
        min-idle: ${SPRING_REDIS_LETTUCE_POOL_MIN_IDLE}
        max-wait: ${SPRING_REDIS_LETTUCE_POOL_MAX_WAIT}
      shutdown-timeout: ${SPRING_REDIS_LETTUCE_SHUTDOWN_TIMEOUT}
  
  # Cache Configuration
  cache:
    type: ${SPRING_CACHE_TYPE}
    redis:
      time-to-live: ${SPRING_CACHE_REDIS_TIME_TO_LIVE}
      cache-null-values: ${SPRING_CACHE_REDIS_CACHE_NULL_VALUES}
  
  # Session Configuration with Redis
  session:
    store-type: ${SPRING_SESSION_STORE_TYPE}
    timeout: ${SPRING_SESSION_TIMEOUT}
    redis:
      namespace: ${SPRING_SESSION_REDIS_NAMESPACE}
      flush-mode: ${SPRING_SESSION_REDIS_FLUSH_MODE}

# Keycloak Configuration
keycloak:
  realm: ${KEYCLOAK_REALM}
  auth-server-url: ${KEYCLOAK_AUTH_SERVER_URL}
  resource: ${KEYCLOAK_RESOURCE}

# Security Configuration (Bank-Level)
security:
  ip:
    whitelist:
      enabled: ${SECURITY_IP_WHITELIST_ENABLED}
      ips: ${SECURITY_IP_WHITELIST_IPS}
    blacklist: ${SECURITY_IP_BLACKLIST}
  cors:
    allowed-origins: ${CORS_ALLOWED_ORIGINS}
  csp:
    connect-src: ${CSP_CONNECT_SRC}
  ratelimit:
    ip: ${RATELIMIT_IP}
    login: ${RATELIMIT_LOGIN}
    user: ${RATELIMIT_USER}
    report: ${RATELIMIT_REPORT}

# JWT Configuration (Local Token Generation)
jwt:
  secret: ${JWT_SECRET}
  expiration: ${JWT_EXPIRATION}       
  refresh-expiration: ${JWT_REFRESH_EXPIRATION}  

# JasperReports Configuration
jasperreports:
  template-path: ${JASPER_TEMPLATE_PATH}
  templates:
    users: ${JASPER_TEMPLATE_USERS}
    tickets: ${JASPER_TEMPLATE_TICKETS}

logging:
  level:
    org.keycloak: ${LOGGING_LEVEL_ORG_KEYCLOAK}
    org.springframework.security: ${LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_SECURITY}
    # Audit logging
    AUDIT: ${LOGGING_LEVEL_AUDIT}

